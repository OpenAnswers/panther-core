
# 
# Copyright (C) 2022, Open Answers Ltd http://www.openanswers.co.uk/
# All rights reserved.
# This file is subject to the terms and conditions defined in the Software License Agreement.
#  

# Logging module
{ logger, debug}  = require('oa-logging')('oa:event:events:fixme')

# node modules
util              = require 'util'

# npm modules
Promise           = require 'bluebird'
if process.env.NODE_ENV is undefined or process.env.NODE_ENV is 'development'
  logger.warn 'enabling Promise long stack traces - Promise.longStackTraces()'
  Promise.longStackTraces()

# OA modules
{ Path }          = require "../../lib/path"
{ SocketIO }      = require "../../lib/socketio"
{ Mongoose }      = require "../../lib/mongoose"
{ Activities }    = require "../../lib/activities"
{ User }          = require "../model/user"
{ Severity }      = require "../model/severity"
{ Filters }       = require "../model/filters"
{ _
  objhash
  throw_error }   = require 'oa-helpers'
{ server_event }  = require "../../lib/eventemitter"

config            = require("../../lib/config").get_instance()


Errors = require '../../lib/errors'



# ### socketio::connect

server_event.on 'oa::events::populate', ( msg )->
  debug 'oa::events::populate msg', msg.message

  limit  = config.app.view_limit

  find_socket_filter_db( msg.socket )
  .then ( query )->

    fields = { notes: 0, history: 0 }

    # Return a new promise... and then
    Mongoose.alerts.find( query, fields )
    .sort( state_change: -1 )
    .limit( limit )
    .toArray()

  .then ( docs )->
    if docs.length > 0
      debug 'emitting', docs.length, docs
      msg.socket.emit 'inserts', data: docs
      if docs.length >= limit
        msg.socket.ev.warn "Limiting view to newest #{limit} events"

    else
      logger.info 'Initial populate query found nada', docs
      msg.socket.emit 'inserts', data: []
      msg.socket.ev.info 'No events matched filter'

  .catch Errors.QueryError, ( err )->
    logger.error "No filter. never mind"

  .catch Promise.OperationalError, ( err )->
    logger.error "Unable load filter, because: ", err.message

  .catch ( err )->
    throw err

  true



# Promise to find a filter for a socket
# This (and things like it) need a home. controllers?
find_socket_filter_db = ( socket )->
  new Promise ( resolve, reject )->
    debug 'evs', socket.ev?.id
    evs = socket.ev

    unless evs
      return reject new Errors.SocketError('No ev property attached to socket')

    unless evs.user()
      return reject new Errors.SocketError('No user attached to socket')

    # If we already have a filter on this socket, no need to find the default
    if filter = evs.event_filter_running()
      return resolve(filter)

    debug 'find_socket_filter running query for default filter'

    Filters.findOne( user: evs.user(), default: true )
    .then ( doc )->
      unless doc?
        logger.error "No default filter found for user [%s] using {}", evs.user()
        resolve evs.event_filter({})
      else
        resolve evs.event_filter doc.f
    .catch ( err )->
      return reject(err)
      
    .finally ->
      debug 'find_socket_filter finally'




# Set a filter for a socket
# This is a req/response so has a client callback
server_event.on 'oa::events::set_filter', ( msg )->
  logger.info msg.socket.id, 'setting the filter to', msg.data.id
  evs = msg.socket.ev

  unless id = Mongoose.recid_to_objectid_false msg.data.id
    msg.socket.ev.warn 'Filter id not valid', id
    return false

  Filters.findOne( user: evs.user(), _id: id )
  .then ( doc )->
    unless doc?
      evs.warn "No default filter found, using all"
      evs.event_filter {}
      msg.cb() if msg.cb?
    else
      filter = if doc.f is undefined then {} else doc.f
      evs.event_filter filter
      msg.cb() if msg.cb?

  .catch ( err )->
    throw err




server_event.on 'oa::events::updates', ( msg )->
  # This is all the updated events from the db (ish, the `state_change` timestamp
  #  acts a bit odd under load when there are processing delays)
  # It needs to be filtered down for each clients filter.
  # This could be done with filter name spaces that clients connect to.
  # Then they can share the room
  # Sift could do the filtering

  # Store the objhash and filter somewhere for reference

  # garbage collect the room as they are used/unused

  logger.info 'Sending out doc deltas', msg.docs.length
  SocketIO.io.emit 'deltas',
    updates: msg.docs
    inserts: []

  # this might be better as a query poll per filter?
  # Then there is no sift and we're not tying up the node process.
  # on large updates, mongo would have most stuff in memory already
  # and can probably do the filtering a lot faster than js

  # for room in rooms
  #   for doc in docs
  #     room.sift doc



# ### oa::events::deletes
#
# This is the delete event event, normally generated by a client
# sending a socketio delete message
server_event.on 'oa::events::deletes', ( msg )->
  debug 'oa::events::deletes msg', msg.data
  return unless SocketIO.socket_check_ids msg

  object_ids = Mongoose.recids_to_objectid msg.data.ids

  logger.info msg.socket.id, msg.socket.ev.user(), 'deleting ids', object_ids.join(', ')

  # Setup a query
  remove_query = _id: $in: object_ids

  # Then run it
  # This should move the document into a "deleted" collection
  # Then this can be monitored for deletes and cleared up on a 
  # custom TTL 
  Mongoose.alerts.remove( remove_query )
  .then ( remove )->
    logger.info msg.socket.id, 'deleted ids', remove.result.n
    
    msg.socket.emit 'message',
      message: 'deleted ids'
      rows: remove.result.n
    
    server_event.emit 'oa::events::deleted',
      ids: msg.data.ids
      source: 'fixme'

    if msg.cb
      msg.cb null, remove.result.n
    
    Activities.store_event 'delete',
      msg.socket.ev.user(),
      ids: msg.data.ids


  .catch ( err )->
    err.message = "Failed to remove ids #{object_ids.join(',')}: " + err.message
    logger.error 'Deletes failed', err
    server_event.emit 'error', err







# ### type_to_history_text( type, set_fields )

# We need to log some information for each update type
# All messages for the types are stored here and looked up 
# via their name.
# `fields` will be used for any %s string replacements (via urtil.format)

# `type` - the type of message to create
# `set_fields` - the data being set in this operation
# Returns - A formatted message string

type_to_history_text = ( type, set_fields )->
  types =
    acknowledge:
      message: 'Acknowleged'
    unacknowledge:
      message: 'Unacknowledged'
    assign:
      message: 'Assigned to %s'
      fields: [ 'owner' ]
    severity:
      message: 'Changed severity to %s'
      fields: [ 'severity' ]
    clear:
      message: 'Cleared event'

  # place for util.format args
  vars = []
  if types[type].fields?
    for name in types[type].fields
      vars.push set_fields[name]

  util.format types[type].message, vars...



# ###### apply_updates_db( type, ids, set_fields, user )

# Promise to apply DB updates for events

apply_updates_db = ( type, ids, set_fields, user = 'system' )->
  new Promise ( resolve, reject )->

    object_ids = Mongoose.recids_to_objectid ids

    query = _id: $in: object_ids
    updates =
      $set: set_fields
      $push:
        history:
          timestamp: new Date()
          user:      user
          message:   type_to_history_text( type, set_fields )

    Mongoose.alerts.update( query, updates, multi: true )
    .then ( update )->
      debug type, ids, update.result, type


      server_event.emit "oa::events::updated",
        type: type
        ids: ids
        source: 'apply_updates_db'

      resolve update.result

    .catch ( err )->
      err.message = "Failed to #{type} ids #{object_ids.join(',')}: " + err.message
      logger.error 'Update failed', type, err, err.stack
      reject err



# ###### apply_updates_db( type, ids, set_fields, socket, socket_cb )

# Promise to apply DB updates from a socket connection
# Includes logging and the client callback from the socket

apply_socket_updates_db = ( type, ids, set_fields, socket, socket_cb )->
  new Promise ( resolve, reject )->

    apply_updates_db( type, ids, set_fields, socket.ev.user() )
    .then ( result )->
      debug socket.id, type, ids, result, type

      logger.info "socket [%s] user [%s] set [%s] on ids [%s]",
        socket.id, socket.ev.user(), type, ids, ''
      
      if socket_cb
        socket_cb null, result.n

      resolve result

    .catch Errors.ValidationError, ( err )->
      logger.error "apply_socket_updates_db validation error", err, err.stack
      socket.ev.error err.message

    .catch ( err )->
      reject err



# ### oa::events::severity

# This is the severity event, normally generated by a client
# sending a socketio change sev message
server_event.on 'oa::events::severity', ( msg )->
  debug 'oa::events::severity msg', msg.data
  return unless SocketIO.socket_check_ids msg
  
  unless msg.data.severity?
    return socket.ev.exception "SocketMsgError",
      "No severity on message"

  unless !isNaN msg.data.severity and msg.data.severity != ''
    return socket.ev.exception "SocketMsgError",
      "Severity is not a number [#{msg.data.severity}]"

  # Setup the queries
  set_fields =
    severity:     parseInt msg.data.severity
    state_change: Date.now()

  # Now promise through it
  Severity.findOne( value: msg.data.severity )
  .then ( doc )->
    unless doc?
      return msg.socket.ev.exception "QueryError",
        "No severities found [#{msg.data.severity}]"

    apply_socket_updates_db 'severity',
      msg.data.ids,
      set_fields,
      msg.socket,
      msg.cb

  .then ( update )->
    logger.info msg.socket.id, 'severitying ids [%j]', update.result, ''

    metadata =
      ids: msg.data.ids
      new_severity: msg.data.severity

    Activities.store_event 'severity',
      msg.socket.ev.user(),
      metadata

  .catch ( err )->
    id_string = msg.data.ids.join(',')
    err.message = "Failed to set severity on ids #{id_string}: " + err.message
    logger.error 'Severitize failed', err, err.stack
    server_event.emit 'error', err




# ### oa::event::add_note

# Return the full data for a single alert
# Seperated as we limit the 'view' data down to the required columns

server_event.on 'oa::event::add_note', ( msg )->
  debug 'oa::event::add_note msg', msg.data
  
  unless SocketIO.socket_check_msg(msg) and SocketIO.socket_check_data(msg)
    return false

  evs = msg.socket.ev

  unless id = Mongoose.recid_to_objectid_false msg.data.id
    evs.warn "Invalid event id for note", msg.data.id
    return false

  query = _id: id
  updates =
    $push:
      notes:
        timestamp: new Date()
        user:      evs.user()
        message:   msg.data.message

  Mongoose.alerts.update( query, updates )
  .then ( update )->
    if update.result.n? and update.result.n == 1
      debug 'oa::event::add_note ', update.result, id
      msg.cb null, update.result.n
    else
      evs.exception 'QueryError', "Attempted to add note for [#{id}] but it wasn't there"

  .catch (error)->
    evs.error 'QueryError', "There was a problem selecting event [#{id}]"
    server_event.emit('error', error)
